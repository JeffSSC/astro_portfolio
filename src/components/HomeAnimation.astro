---

---

<div id="canvas-container" class="absolute top-0 left-0 w-full h-full -z-10">
</div>

<script>
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

    const container = document.getElementById("canvas-container");

    if (container) {
        let width = container.clientWidth;
        let height = container.clientHeight;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            60,
            width / height,
            0.1,
            100,
        );
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance",
        });

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.dispose();

        const geometry = new THREE.SphereGeometry(1, 64, 64);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uScale: { value: 6.0 },
                uDepth: { value: 1 },
                uSharpness: { value: 3.0 },
                uSpeed: { value: 0 },
                uColor: { value: new THREE.Color("#ff00f1") },
                uNoiseScale: { value: 1.5 },
                uNoiseStrength: { value: 0.5 },
                uOutlineWidth: { value: 0.5 },
                uOutlineColor: { value: new THREE.Color("#0a0060") },
                uSecondaryColor: { value: new THREE.Color("#ff005f") },
                uDisplacementStrength: { value: 1 },
            },
            vertexShader: `
                uniform float uTime;
                uniform float uScale;
                uniform float uSharpness;
                uniform float uSpeed;
                uniform float uNoiseScale;
                uniform float uNoiseStrength;
                uniform float uDisplacementStrength;
                varying vec3 vNormal;
                varying vec3 v3Position;
                varying float vShellPattern;
                varying vec3 vViewPosition;
                
                float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
                
                // ... (noise functions remain the same, omitted for brevity if not changing) ...
                // Re-including noise functions to ensure context match if needed, but since I'm replacing the whole block or just the main/varying parts.
                // Let's replace the main function and varying declarations to be safe.
                
                float noise(vec2 uv, float timeOffset) {
                    vec2 i = floor(uv);
                    vec2 f = fract(uv);
                    float a = hash(i + vec2(timeOffset));
                    float b = hash(i + vec2(1.0, 0.0) + vec2(timeOffset));
                    float c = hash(i + vec2(0.0, 1.0) + vec2(timeOffset));
                    float d = hash(i + vec2(1.0, 1.0) + vec2(timeOffset));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                }
                float voronoi(vec2 uv, float t) {
                    vec2 g = floor(uv);
                    vec2 f = fract(uv);
                    float minDist1 = 1.0; float secondMinDist1 = 1.0;
                    float minDist2 = 1.0; float secondMinDist2 = 1.0;
                    float t0 = t; float t1 = t + 1.0;
                    float a = smoothstep(0.0, 1.0, fract(t));
                    for (int y = -1; y <= 1; y++) {
                        for (int x = -1; x <= 1; x++) {
                            vec2 lattice = vec2(x, y);
                            vec2 perturbed_lattice = lattice + uNoiseStrength * (noise((g + lattice) * uNoiseScale, t0) * 2.0 - 1.0);
                            vec2 point = hash(g + perturbed_lattice) + perturbed_lattice - f;
                            float dist = length(point);
                            if (dist < minDist1) { secondMinDist1 = minDist1; minDist1 = dist; }
                            else if (dist < secondMinDist1) { secondMinDist1 = dist; }
                        }
                    }
                    for (int y = -1; y <= 1; y++) {
                        for (int x = -1; x <= 1; x++) {
                            vec2 lattice = vec2(x, y);
                            vec2 perturbed_lattice = lattice + uNoiseStrength * (noise((g + lattice) * uNoiseScale, t1) * 2.0 - 1.0);
                            vec2 point = hash(g + perturbed_lattice) + perturbed_lattice - f;
                            float dist = length(point);
                            if (dist < minDist2) { secondMinDist2 = minDist2; minDist2 = dist; }
                            else if (dist < secondMinDist2) { secondMinDist2 = dist; }
                        }
                    }
                    float pattern1 = secondMinDist1 - minDist1;
                    float pattern2 = secondMinDist2 - minDist2;
                    return mix(pattern1, pattern2, a);
                }
                float triplanar(vec3 p, vec3 normal, float t) {
                    vec3 blending = abs(normal);
                    blending = normalize(max(blending, 0.00001));
                    blending /= (blending.x + blending.y + blending.z);
                    float x = voronoi(p.yz * uScale, t);
                    float y = voronoi(p.xz * uScale, t);
                    float z = voronoi(p.xy * uScale, t);
                    return (x * blending.x + y * blending.y + z * blending.z);
                }
                void main() {
                    vec3 transformedNormal = normalize(normalMatrix * normal);
                    vec3 displacedPosition = position;
                    float time = uTime * uSpeed;
                    float patternValue = triplanar(position, normal, time);
                    vShellPattern = patternValue;
                    float softPattern = smoothstep(0.2, 0.8, patternValue);
                    float displacementFactor = softPattern * uDisplacementStrength;
                    displacedPosition += normal * displacementFactor;
                    vNormal = transformedNormal;
                    v3Position = position;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(displacedPosition, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform float uDepth;
                uniform vec3 uColor;
                uniform float uOutlineWidth;
                uniform vec3 uOutlineColor;
                uniform vec3 uSecondaryColor;
                varying vec3 vNormal;
                varying vec3 v3Position;
                varying float vShellPattern;
                varying vec3 vViewPosition;
                
                void main() {
                    float steppedPattern = smoothstep(uOutlineWidth, uOutlineWidth + 0.2, vShellPattern);
                    vec3 lightDirection = normalize(vec3(0.5, 0.5, 1.0));
                    float lighting = dot(vNormal, lightDirection) * 0.5 + 0.5;
                    
                    // Base color mixing
                    vec3 baseColor = mix(uOutlineColor, uSecondaryColor, steppedPattern);
                    
                    // Fresnel Effect
                    vec3 viewDir = normalize(vViewPosition);
                    float fresnel = pow(1.0 - max(0.0, dot(vNormal, viewDir)), 3.0);
                    
                    // Combine
                    float highlightIntensity = smoothstep(0.0, 0.5, vShellPattern);
                    vec3 finalColor = baseColor + uColor * highlightIntensity * uDepth * lighting;
                    
                    // Add Fresnel glow
                    finalColor += uColor * fresnel * 0.8;
                    
                    gl_FragColor = vec4(finalColor * lighting, 1.0);
                }
            `,
            wireframe: true,
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(width, height),
            0.8,
            0.4,
            1.0,
        );
        composer.addPass(bloomPass);

        function getRandomHSL() {
            const h = Math.random();
            const s = 0.6 + Math.random() * 0.4;
            const l = 0.1 + Math.random() * 0.2;
            return { h, s, l };
        }

        const randomizer = {
            randomize: () => {
                material.uniforms.uScale.value = 1 + Math.random() * 19;
                material.uniforms.uDepth.value = Math.random() * 2;
                material.uniforms.uSharpness.value = 1 + Math.random() * 9;
                const color = getRandomHSL();
                material.uniforms.uColor.value.setHSL(
                    color.h,
                    color.s,
                    color.l,
                );
                material.uniforms.uNoiseScale.value = 0.1 + Math.random() * 4.9;
                material.uniforms.uNoiseStrength.value = Math.random() * 1;
                material.uniforms.uOutlineWidth.value =
                    0.01 + Math.random() * 0.99;
                const color2 = getRandomHSL();
                material.uniforms.uOutlineColor.value.setHSL(
                    color2.h,
                    color2.s,
                    color2.l,
                );
                const color3 = getRandomHSL();
                material.uniforms.uSecondaryColor.value.setHSL(
                    color3.h,
                    color3.s,
                    color3.l,
                );
                material.uniforms.uDisplacementStrength.value =
                    -0.5 + Math.random() * 2.0;
            },
        };

        window.addEventListener("resize", () => {
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
            composer.setSize(newWidth, newHeight);
        });

        let isVisible = true;

        function animate(time: number) {
            requestAnimationFrame(animate);
            if (!isVisible) return;

            material.uniforms.uTime.value = time * 0.001;
            mesh.rotation.y += 0.005;
            composer.render();
        }

        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    isVisible = entry.isIntersecting;
                });
            },
            { threshold: 0 },
        );

        observer.observe(container);

        randomizer.randomize();
        animate(0);
    }
</script>
