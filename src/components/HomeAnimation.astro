---

---

<div id="canvas-container" class="absolute top-0 left-0 w-full h-full -z-10">
</div>

<script>
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

    const container = document.getElementById("canvas-container");

    if (container) {
        let isInitialized = false;
        let renderer: THREE.WebGLRenderer;
        let composer: EffectComposer;
        let camera: THREE.PerspectiveCamera;
        let mesh: THREE.Mesh;
        let material: THREE.ShaderMaterial;
        let isVisible = false;
        let animationId: number;

        const init = () => {
            if (isInitialized) return;
            isInitialized = true;

            let width = container.clientWidth;
            let height = container.clientHeight;

            const scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            camera.position.z = 6;

            renderer = new THREE.WebGLRenderer({
                antialias: false, // Disable antialias for performance
                alpha: true,
                powerPreference: "high-performance",
                stencil: false,
                depth: true,
            });

            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio

            container.appendChild(renderer.domElement);

            // No controls needed for background animation
            // const controls = new OrbitControls(camera, renderer.domElement);
            // controls.dispose();

            const geometry = new THREE.SphereGeometry(1, 32, 32);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 6.0 },
                    uDepth: { value: 1 },
                    uSharpness: { value: 3.0 },
                    uSpeed: { value: 0 },
                    uColor: { value: new THREE.Color("#ff00f1") },
                    uNoiseScale: { value: 1.5 },
                    uNoiseStrength: { value: 0.5 },
                    uOutlineWidth: { value: 0.5 },
                    uOutlineColor: { value: new THREE.Color("#0a0060") },
                    uSecondaryColor: { value: new THREE.Color("#ff005f") },
                    uDisplacementStrength: { value: 1 },
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uScale;
                    uniform float uSharpness;
                    uniform float uSpeed;
                    uniform float uNoiseScale;
                    uniform float uNoiseStrength;
                    uniform float uDisplacementStrength;
                    varying vec3 vNormal;
                    varying vec3 v3Position;
                    varying float vShellPattern;
                    varying vec3 vViewPosition;
                    
                    float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
                    
                    float noise(vec2 uv, float timeOffset) {
                        vec2 i = floor(uv);
                        vec2 f = fract(uv);
                        float a = hash(i + vec2(timeOffset));
                        float b = hash(i + vec2(1.0, 0.0) + vec2(timeOffset));
                        float c = hash(i + vec2(0.0, 1.0) + vec2(timeOffset));
                        float d = hash(i + vec2(1.0, 1.0) + vec2(timeOffset));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                    }
                    float voronoi(vec2 uv, float t) {
                        vec2 g = floor(uv);
                        vec2 f = fract(uv);
                        float minDist1 = 1.0; float secondMinDist1 = 1.0;
                        float minDist2 = 1.0; float secondMinDist2 = 1.0;
                        float t0 = t; float t1 = t + 1.0;
                        float a = smoothstep(0.0, 1.0, fract(t));
                        for (int y = -1; y <= 1; y++) {
                            for (int x = -1; x <= 1; x++) {
                                vec2 lattice = vec2(x, y);
                                vec2 perturbed_lattice = lattice + uNoiseStrength * (noise((g + lattice) * uNoiseScale, t0) * 2.0 - 1.0);
                                vec2 point = hash(g + perturbed_lattice) + perturbed_lattice - f;
                                float dist = length(point);
                                if (dist < minDist1) { secondMinDist1 = minDist1; minDist1 = dist; }
                                else if (dist < secondMinDist1) { secondMinDist1 = dist; }
                            }
                        }
                        for (int y = -1; y <= 1; y++) {
                            for (int x = -1; x <= 1; x++) {
                                vec2 lattice = vec2(x, y);
                                vec2 perturbed_lattice = lattice + uNoiseStrength * (noise((g + lattice) * uNoiseScale, t1) * 2.0 - 1.0);
                                vec2 point = hash(g + perturbed_lattice) + perturbed_lattice - f;
                                float dist = length(point);
                                if (dist < minDist2) { secondMinDist2 = minDist2; minDist2 = dist; }
                                else if (dist < secondMinDist2) { secondMinDist2 = dist; }
                            }
                        }
                        float pattern1 = secondMinDist1 - minDist1;
                        float pattern2 = secondMinDist2 - minDist2;
                        return mix(pattern1, pattern2, a);
                    }
                    float triplanar(vec3 p, vec3 normal, float t) {
                        vec3 blending = abs(normal);
                        blending = normalize(max(blending, 0.00001));
                        blending /= (blending.x + blending.y + blending.z);
                        float x = voronoi(p.yz * uScale, t);
                        float y = voronoi(p.xz * uScale, t);
                        float z = voronoi(p.xy * uScale, t);
                        return (x * blending.x + y * blending.y + z * blending.z);
                    }
                    void main() {
                        vec3 transformedNormal = normalize(normalMatrix * normal);
                        vec3 displacedPosition = position;
                        float time = uTime * uSpeed;
                        float patternValue = triplanar(position, normal, time);
                        vShellPattern = patternValue;
                        float softPattern = smoothstep(0.2, 0.8, patternValue);
                        float displacementFactor = softPattern * uDisplacementStrength;
                        displacedPosition += normal * displacementFactor;
                        vNormal = transformedNormal;
                        v3Position = position;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(displacedPosition, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform float uDepth;
                    uniform vec3 uColor;
                    uniform float uOutlineWidth;
                    uniform vec3 uOutlineColor;
                    uniform vec3 uSecondaryColor;
                    varying vec3 vNormal;
                    varying vec3 v3Position;
                    varying float vShellPattern;
                    varying vec3 vViewPosition;
                    
                    void main() {
                        float steppedPattern = smoothstep(uOutlineWidth, uOutlineWidth + 0.2, vShellPattern);
                        vec3 lightDirection = normalize(vec3(0.5, 0.5, 1.0));
                        float lighting = dot(vNormal, lightDirection) * 0.5 + 0.5;
                        
                        // Base color mixing
                        vec3 baseColor = mix(uOutlineColor, uSecondaryColor, steppedPattern);
                        
                        // Fresnel Effect
                        vec3 viewDir = normalize(vViewPosition);
                        float fresnel = pow(1.0 - max(0.0, dot(vNormal, viewDir)), 3.0);
                        
                        // Combine
                        float highlightIntensity = smoothstep(0.0, 0.5, vShellPattern);
                        vec3 finalColor = baseColor + uColor * highlightIntensity * uDepth * lighting;
                        
                        // Add Fresnel glow
                        finalColor += uColor * fresnel * 0.8;
                        
                        gl_FragColor = vec4(finalColor * lighting, 1.0);
                    }
                `,
                wireframe: true,
            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5);
            scene.add(light);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(width, height),
                0.8,
                0.4,
                1.0,
            );
            composer.addPass(bloomPass);

            randomizer.randomize();

            window.addEventListener("resize", onResize);
            animate(0);
        };

        function getRandomHSL() {
            const h = Math.random();
            const s = 0.6 + Math.random() * 0.4;
            const l = 0.1 + Math.random() * 0.2;
            return { h, s, l };
        }

        const randomizer = {
            randomize: () => {
                if (!material) return;
                material.uniforms.uScale.value = 1 + Math.random() * 19;
                material.uniforms.uDepth.value = Math.random() * 2;
                material.uniforms.uSharpness.value = 1 + Math.random() * 9;
                const color = getRandomHSL();
                material.uniforms.uColor.value.setHSL(
                    color.h,
                    color.s,
                    color.l,
                );
                material.uniforms.uNoiseScale.value = 0.1 + Math.random() * 4.9;
                material.uniforms.uNoiseStrength.value = Math.random() * 1;
                material.uniforms.uOutlineWidth.value =
                    0.01 + Math.random() * 0.99;
                const color2 = getRandomHSL();
                material.uniforms.uOutlineColor.value.setHSL(
                    color2.h,
                    color2.s,
                    color2.l,
                );
                const color3 = getRandomHSL();
                material.uniforms.uSecondaryColor.value.setHSL(
                    color3.h,
                    color3.s,
                    color3.l,
                );
                material.uniforms.uDisplacementStrength.value =
                    -0.5 + Math.random() * 2.0;
            },
        };

        const onResize = () => {
            if (!container || !camera || !renderer || !composer) return;
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
            composer.setSize(newWidth, newHeight);
        };

        function animate(time: number) {
            animationId = requestAnimationFrame(animate);
            if (!isVisible || !isInitialized) return;

            material.uniforms.uTime.value = time * 0.001;
            mesh.rotation.y += 0.005;
            composer.render();
        }

        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    isVisible = entry.isIntersecting;
                    if (isVisible && !isInitialized) {
                        // Use requestIdleCallback to avoid blocking the main thread immediately
                        if ("requestIdleCallback" in window) {
                            (window as any).requestIdleCallback(() => init());
                        } else {
                            setTimeout(init, 100);
                        }
                    }
                });
            },
            { threshold: 0 },
        );

        observer.observe(container);
    }
</script>
